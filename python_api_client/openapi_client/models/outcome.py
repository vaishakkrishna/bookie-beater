# coding: utf-8

"""
    The Odds API

    To access the API, get a free API key from https://the-odds-api.com

    The version of the OpenAPI document: 4
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictFloat, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional, Union
from typing import Optional, Set
from typing_extensions import Self

class Outcome(BaseModel):
    """
    Outcome
    """ # noqa: E501
    name: Optional[StrictStr] = Field(default=None, description="The outcome label. The value will depend on the market. For totals markets, this will be 'Over' or 'Under'. For team markets, it will be the name of the team or participant, or 'Draw'")
    price: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The odds of the outcome. The format is determined by the oddsFormat query param. The format is decimal by default.")
    point: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The handicap or points of the outcome, only applicable to spreads and totals markets (this property will be missing for h2h and outrights markets)")
    description: Optional[StrictStr] = Field(default=None, description="This field is only relevant for certain markets. It contains more information about the outcome (for example, for player prop markets, it includes the player's name)")
    link: Optional[StrictStr] = Field(default=None, description="If available, link to the bookmaker's website and populate the betslip. This field is included when providing the query parameter includeLinks=true")
    sid: Optional[StrictStr] = Field(default=None, description="The bookmaker's id for the bet selection, if available. This field is included when providing the query parameter includeSids=true")
    bet_limit: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The bookmaker's or exchange's monetary limit on the betting selection. The currency will depend on the bookmaker/exchange. This field is included when providing the query parameter includeBetLimits=true, and is mainly populated for betting exchanges.")
    __properties: ClassVar[List[str]] = ["name", "price", "point", "description", "link", "sid", "bet_limit"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Outcome from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # set to None if point (nullable) is None
        # and model_fields_set contains the field
        if self.point is None and "point" in self.model_fields_set:
            _dict['point'] = None

        # set to None if description (nullable) is None
        # and model_fields_set contains the field
        if self.description is None and "description" in self.model_fields_set:
            _dict['description'] = None

        # set to None if link (nullable) is None
        # and model_fields_set contains the field
        if self.link is None and "link" in self.model_fields_set:
            _dict['link'] = None

        # set to None if sid (nullable) is None
        # and model_fields_set contains the field
        if self.sid is None and "sid" in self.model_fields_set:
            _dict['sid'] = None

        # set to None if bet_limit (nullable) is None
        # and model_fields_set contains the field
        if self.bet_limit is None and "bet_limit" in self.model_fields_set:
            _dict['bet_limit'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Outcome from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "name": obj.get("name"),
            "price": obj.get("price"),
            "point": obj.get("point"),
            "description": obj.get("description"),
            "link": obj.get("link"),
            "sid": obj.get("sid"),
            "bet_limit": obj.get("bet_limit")
        })
        return _obj


